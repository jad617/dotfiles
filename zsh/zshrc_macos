##################################
# 0) Guard non-interactive shells
##################################
[[ -o interactive ]] || return

ZDOT=${ZDOTDIR:-$HOME}

##################################
# 0.5) Function path for completions (Terraform writes here)
##################################
ZFUNC_DIR="$HOME/.zfunc"
mkdir -p "$ZFUNC_DIR"
fpath=("$ZFUNC_DIR" $fpath)

##################################
# 1) Core Settings & History
##################################
setopt rm_star_silent share_history
HISTSIZE=200000
SAVEHIST=200000
bindkey -e

##################################
# 2) Completion (cached & fast)
##################################
zmodload zsh/complist
autoload -Uz compinit
zstyle ':completion:*' use-cache yes
zstyle ':completion:*' cache-path "$ZDOT/.zcompcache"
setopt AUTO_LIST AUTO_MENU
unsetopt MENU_COMPLETE
zstyle ':completion:*' menu select=1
zstyle ':completion:*:cd:*' tag-order 'local-directories directory-stack path-directories'
zstyle ':completion:*:cd:*' ignore-parents parent pwd
zstyle ':completion:*' squeeze-slashes true
[[ -n $LS_COLORS ]] && zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

if [[ ! -s "$ZDOT/.zcompdump" || "$ZDOT/.zcompdump"(Nm-20) ]]; then
  compinit -i -C
else
  compinit -i
fi

# Bash compat layer (only if something needs it)
autoload -U +X bashcompinit && bashcompinit

##################################
# 2.5) Terraform completion (v1.13+)
##################################
if command -v terraform >/dev/null 2>&1; then
  # One-time install if not present
  if [[ ! -f "$ZFUNC_DIR/_terraform" ]]; then
    terraform -install-autocomplete >/dev/null 2>&1
  fi
  # Load and bind completion if the function exists
  if [[ -f "$ZFUNC_DIR/_terraform" ]]; then
    autoload -Uz _terraform
    compdef _terraform terraform
  fi
fi

##################################
# 3) Navigation & Search
##################################
autoload -Uz up-line-or-beginning-search down-line-or-beginning-search
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search
bindkey '^[[A' up-line-or-beginning-search
bindkey '^[[B' down-line-or-beginning-search
autoload -U select-word-style
select-word-style bash

##################################
# 4) Home / End / Ctrl-Arrows (tmux + WezTerm safe)
##################################
for map in emacs viins vicmd; do
  # Home / End via terminfo + fallbacks
  [[ -n ${terminfo[khome]} ]] && bindkey -M $map "${terminfo[khome]}" beginning-of-line
  [[ -n ${terminfo[kend]}  ]] && bindkey -M $map "${terminfo[kend]}"  end-of-line
  bindkey -M $map "\e[H"  beginning-of-line
  bindkey -M $map "\eOH" beginning-of-line
  bindkey -M $map "\e[F"  end-of-line
  bindkey -M $map "\eOF" end-of-line
  bindkey -M $map "\e[1~" beginning-of-line
  bindkey -M $map "\e[4~" end-of-line

  # Ctrl + Left / Right (common sequences across terminals/tmux)
  [[ -n ${terminfo[kLFT5]} ]] && bindkey -M $map "${terminfo[kLFT5]}" backward-word
  [[ -n ${terminfo[kRIT5]} ]] && bindkey -M $map "${terminfo[kRIT5]}" forward-word
  bindkey -M $map "^[OD" backward-word
  bindkey -M $map "^[OC" forward-word
  bindkey -M $map "\e[1;5D" backward-word
  bindkey -M $map "\e[1;5C" forward-word
  bindkey -M $map "\e[5D" backward-word
  bindkey -M $map "\e[5C" forward-word
done

##################################
# 5) cd helpers
##################################
cd() {
  if [[ $# -eq 1 && $1 == +([.]) ]]; then
    local n=${#1} path=".."
    for ((i=2; i<=n; i++)); do path+="/.."; done
    builtin cd "$path"
  else
    builtin cd "$@"
  fi
}

_cd_parent() {
  if [[ $words[-1] == '..' ]]; then
    compadd -- $(command ls -d ../*/ 2>/dev/null)
  else
    _cd
  fi
}
compdef _cd_parent cd

##################################
# 6) Aliases & Small files
##################################
[[ -f "$HOME/.my_aliases.sh" ]] && source "$HOME/.my_aliases.sh"
[[ -f "$HOME/.my_aliases_non_git.sh" ]] && source "$HOME/.my_aliases_non_git.sh"
[[ -f "$HOME/.fzf.zsh" ]] && source "$HOME/.fzf.zsh"

##################################
# 7) Lazy kubectl completion
##################################
if command -v kubectl >/dev/null 2>&1; then
  _kubectl_lazy() {
    unset -f _kubectl_lazy
    local comp="$HOME/.config/completion/kubectl.sh"
    if [[ ! -f $comp ]]; then
      mkdir -p "$HOME/.config/completion"
      kubectl completion zsh >| "$comp" 2>/dev/null
    fi
    source "$comp"
    _kubectl "$@"
  }
  compdef _kubectl_lazy kubectl k
fi

##################################
# 8) Deferred initializations
##################################
autoload -Uz add-zsh-hook

# --- zoxide (provides `z`) ---
_zoxide_init_once() {
  add-zsh-hook -d precmd _zoxide_init_once
  if command -v zoxide >/dev/null 2>&1; then
    eval "$(zoxide init zsh)"
  fi
}
add-zsh-hook precmd _zoxide_init_once

# --- pyenv (on-demand auto-init) ---
export PYENV_ROOT="$HOME/.pyenv"
[[ -d "$PYENV_ROOT/bin" ]] && path+="$PYENV_ROOT/bin"

_pyenv_init_if_needed() {
  [[ -n "$__PYENV_INIT_DONE" ]] && return
  command -v pyenv >/dev/null 2>&1 || return
  __PYENV_INIT_DONE=1
  eval "$(pyenv init - zsh)"
  eval "$(pyenv virtualenv-init -)"
}

_pyenv_dir_check() {
  emulate -L zsh
  setopt extended_glob null_glob
  local -a py_files=( *.py(N) )
  if [[ -f .python-version ]] || (( ${#py_files} > 0 )) || [[ -d venv || -d .venv ]]; then
    _pyenv_init_if_needed
  fi
}
add-zsh-hook chpwd _pyenv_dir_check
add-zsh-hook precmd _pyenv_dir_check

##################################
# 9) Prompt & Theming
##################################
if command -v oh-my-posh >/dev/null 2>&1; then
  eval "$(oh-my-posh init zsh --config "$HOME/.config/ohmyposh/zsh.toml")"
else
  PROMPT='%F{cyan}%n@%m%f:%F{blue}%~%f %# '
fi

##################################
# 10) Syntax highlighting (last)
##################################
[[ -f /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]] && \
  source /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

complete -o nospace -C /opt/homebrew/bin/terraform terraform
